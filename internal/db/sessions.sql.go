// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package db

import (
	"context"
	"database/sql"
)

const countActiveSessionsByThread = `-- name: CountActiveSessionsByThread :one
SELECT COUNT(*) as count
FROM sessions
WHERE thread_id = ? AND status = 'active'
`

func (q *Queries) CountActiveSessionsByThread(ctx context.Context, threadID int64) (int64, error) {
	row := q.queryRow(ctx, q.countActiveSessionsByThreadStmt, countActiveSessionsByThread, threadID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSessionWithInitialPrompt = `-- name: CreateSessionWithInitialPrompt :one
INSERT INTO sessions (
    thread_id, session_id, model, initial_prompt
) VALUES (
    ?, ?, ?, ?
)
RETURNING id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt
`

type CreateSessionWithInitialPromptParams struct {
	ThreadID      int64          `json:"thread_id"`
	SessionID     string         `json:"session_id"`
	Model         sql.NullString `json:"model"`
	InitialPrompt sql.NullString `json:"initial_prompt"`
}

func (q *Queries) CreateSessionWithInitialPrompt(ctx context.Context, arg CreateSessionWithInitialPromptParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionWithInitialPromptStmt, createSessionWithInitialPrompt,
		arg.ThreadID,
		arg.SessionID,
		arg.Model,
		arg.InitialPrompt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.SessionID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
		&i.Model,
		&i.TotalCostUsd,
		&i.InputTokens,
		&i.OutputTokens,
		&i.DurationMs,
		&i.NumTurns,
		&i.InitialPrompt,
	)
	return i, err
}

const getActiveSessionByThread = `-- name: GetActiveSessionByThread :one
SELECT s.id, s.thread_id, s.session_id, s.started_at, s.ended_at, s.status, s.model, s.total_cost_usd, s.input_tokens, s.output_tokens, s.duration_ms, s.num_turns, s.initial_prompt
FROM sessions s
WHERE s.thread_id = ?
  AND s.status = 'active'
ORDER BY s.started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveSessionByThread(ctx context.Context, threadID int64) (Session, error) {
	row := q.queryRow(ctx, q.getActiveSessionByThreadStmt, getActiveSessionByThread, threadID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.SessionID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
		&i.Model,
		&i.TotalCostUsd,
		&i.InputTokens,
		&i.OutputTokens,
		&i.DurationMs,
		&i.NumTurns,
		&i.InitialPrompt,
	)
	return i, err
}

const getLatestSessionByThread = `-- name: GetLatestSessionByThread :one
SELECT s.id, s.thread_id, s.session_id, s.started_at, s.ended_at, s.status, s.model, s.total_cost_usd, s.input_tokens, s.output_tokens, s.duration_ms, s.num_turns, s.initial_prompt
FROM sessions s
WHERE s.thread_id = ?
  AND s.status = 'completed'
ORDER BY s.ended_at DESC
LIMIT 1
`

func (q *Queries) GetLatestSessionByThread(ctx context.Context, threadID int64) (Session, error) {
	row := q.queryRow(ctx, q.getLatestSessionByThreadStmt, getLatestSessionByThread, threadID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.SessionID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
		&i.Model,
		&i.TotalCostUsd,
		&i.InputTokens,
		&i.OutputTokens,
		&i.DurationMs,
		&i.NumTurns,
		&i.InitialPrompt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
WHERE session_id = ?
LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, sessionID string) (Session, error) {
	row := q.queryRow(ctx, q.getSessionStmt, getSession, sessionID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.SessionID,
		&i.StartedAt,
		&i.EndedAt,
		&i.Status,
		&i.Model,
		&i.TotalCostUsd,
		&i.InputTokens,
		&i.OutputTokens,
		&i.DurationMs,
		&i.NumTurns,
		&i.InitialPrompt,
	)
	return i, err
}

const listActiveSessions = `-- name: ListActiveSessions :many
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
WHERE status = 'active'
ORDER BY started_at DESC
`

func (q *Queries) ListActiveSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.query(ctx, q.listActiveSessionsStmt, listActiveSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.SessionID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
			&i.Model,
			&i.TotalCostUsd,
			&i.InputTokens,
			&i.OutputTokens,
			&i.DurationMs,
			&i.NumTurns,
			&i.InitialPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
ORDER BY started_at DESC
`

func (q *Queries) ListSessions(ctx context.Context) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsStmt, listSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.SessionID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
			&i.Model,
			&i.TotalCostUsd,
			&i.InputTokens,
			&i.OutputTokens,
			&i.DurationMs,
			&i.NumTurns,
			&i.InitialPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByThreadID = `-- name: ListSessionsByThreadID :many
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
WHERE thread_id = ?
ORDER BY started_at DESC
`

func (q *Queries) ListSessionsByThreadID(ctx context.Context, threadID int64) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsByThreadIDStmt, listSessionsByThreadID, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.SessionID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
			&i.Model,
			&i.TotalCostUsd,
			&i.InputTokens,
			&i.OutputTokens,
			&i.DurationMs,
			&i.NumTurns,
			&i.InitialPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByThreadIDPaginated = `-- name: ListSessionsByThreadIDPaginated :many
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
WHERE thread_id = ?
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListSessionsByThreadIDPaginatedParams struct {
	ThreadID int64 `json:"thread_id"`
	Limit    int64 `json:"limit"`
	Offset   int64 `json:"offset"`
}

func (q *Queries) ListSessionsByThreadIDPaginated(ctx context.Context, arg ListSessionsByThreadIDPaginatedParams) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsByThreadIDPaginatedStmt, listSessionsByThreadIDPaginated, arg.ThreadID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.SessionID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
			&i.Model,
			&i.TotalCostUsd,
			&i.InputTokens,
			&i.OutputTokens,
			&i.DurationMs,
			&i.NumTurns,
			&i.InitialPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsPaginated = `-- name: ListSessionsPaginated :many
SELECT id, thread_id, session_id, started_at, ended_at, status, model, total_cost_usd, input_tokens, output_tokens, duration_ms, num_turns, initial_prompt FROM sessions
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListSessionsPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSessionsPaginated(ctx context.Context, arg ListSessionsPaginatedParams) ([]Session, error) {
	rows, err := q.query(ctx, q.listSessionsPaginatedStmt, listSessionsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Session
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.SessionID,
			&i.StartedAt,
			&i.EndedAt,
			&i.Status,
			&i.Model,
			&i.TotalCostUsd,
			&i.InputTokens,
			&i.OutputTokens,
			&i.DurationMs,
			&i.NumTurns,
			&i.InitialPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSessionEndTime = `-- name: UpdateSessionEndTime :exec
UPDATE sessions
SET status = ?,
    ended_at = CURRENT_TIMESTAMP
WHERE session_id = ?
`

type UpdateSessionEndTimeParams struct {
	Status    sql.NullString `json:"status"`
	SessionID string         `json:"session_id"`
}

func (q *Queries) UpdateSessionEndTime(ctx context.Context, arg UpdateSessionEndTimeParams) error {
	_, err := q.exec(ctx, q.updateSessionEndTimeStmt, updateSessionEndTime, arg.Status, arg.SessionID)
	return err
}

const updateSessionID = `-- name: UpdateSessionID :exec
UPDATE sessions
SET session_id = ?
WHERE session_id = ?
`

type UpdateSessionIDParams struct {
	SessionID   string `json:"session_id"`
	SessionID_2 string `json:"session_id_2"`
}

func (q *Queries) UpdateSessionID(ctx context.Context, arg UpdateSessionIDParams) error {
	_, err := q.exec(ctx, q.updateSessionIDStmt, updateSessionID, arg.SessionID, arg.SessionID_2)
	return err
}

const updateSessionModel = `-- name: UpdateSessionModel :exec
UPDATE sessions
SET model = ?
WHERE session_id = ?
`

type UpdateSessionModelParams struct {
	Model     sql.NullString `json:"model"`
	SessionID string         `json:"session_id"`
}

func (q *Queries) UpdateSessionModel(ctx context.Context, arg UpdateSessionModelParams) error {
	_, err := q.exec(ctx, q.updateSessionModelStmt, updateSessionModel, arg.Model, arg.SessionID)
	return err
}

const updateSessionOnComplete = `-- name: UpdateSessionOnComplete :exec
UPDATE sessions
SET status = ?,
    ended_at = ?,
    total_cost_usd = ?,
    input_tokens = ?,
    output_tokens = ?,
    num_turns = ?,
    model = ?
WHERE session_id = ?
`

type UpdateSessionOnCompleteParams struct {
	Status       sql.NullString  `json:"status"`
	EndedAt      sql.NullTime    `json:"ended_at"`
	TotalCostUsd sql.NullFloat64 `json:"total_cost_usd"`
	InputTokens  sql.NullInt64   `json:"input_tokens"`
	OutputTokens sql.NullInt64   `json:"output_tokens"`
	NumTurns     sql.NullInt64   `json:"num_turns"`
	Model        sql.NullString  `json:"model"`
	SessionID    string          `json:"session_id"`
}

func (q *Queries) UpdateSessionOnComplete(ctx context.Context, arg UpdateSessionOnCompleteParams) error {
	_, err := q.exec(ctx, q.updateSessionOnCompleteStmt, updateSessionOnComplete,
		arg.Status,
		arg.EndedAt,
		arg.TotalCostUsd,
		arg.InputTokens,
		arg.OutputTokens,
		arg.NumTurns,
		arg.Model,
		arg.SessionID,
	)
	return err
}

const updateSessionStatus = `-- name: UpdateSessionStatus :exec
UPDATE sessions
SET status = ?,
    ended_at = CURRENT_TIMESTAMP,
    total_cost_usd = ?,
    input_tokens = ?,
    output_tokens = ?,
    duration_ms = ?,
    num_turns = ?
WHERE session_id = ?
`

type UpdateSessionStatusParams struct {
	Status       sql.NullString  `json:"status"`
	TotalCostUsd sql.NullFloat64 `json:"total_cost_usd"`
	InputTokens  sql.NullInt64   `json:"input_tokens"`
	OutputTokens sql.NullInt64   `json:"output_tokens"`
	DurationMs   sql.NullInt64   `json:"duration_ms"`
	NumTurns     sql.NullInt64   `json:"num_turns"`
	SessionID    string          `json:"session_id"`
}

func (q *Queries) UpdateSessionStatus(ctx context.Context, arg UpdateSessionStatusParams) error {
	_, err := q.exec(ctx, q.updateSessionStatusStmt, updateSessionStatus,
		arg.Status,
		arg.TotalCostUsd,
		arg.InputTokens,
		arg.OutputTokens,
		arg.DurationMs,
		arg.NumTurns,
		arg.SessionID,
	)
	return err
}
