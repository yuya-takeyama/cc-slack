// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: threads.sql

package db

import (
	"context"
	"database/sql"
)

const createThread = `-- name: CreateThread :one
INSERT INTO threads (
    channel_id, thread_ts, working_directory
) VALUES (
    ?, ?, ?
)
RETURNING id, channel_id, thread_ts, working_directory, created_at, updated_at
`

type CreateThreadParams struct {
	ChannelID        string `json:"channel_id"`
	ThreadTs         string `json:"thread_ts"`
	WorkingDirectory string `json:"working_directory"`
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (Thread, error) {
	row := q.queryRow(ctx, q.createThreadStmt, createThread, arg.ChannelID, arg.ThreadTs, arg.WorkingDirectory)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.WorkingDirectory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getThread = `-- name: GetThread :one
SELECT id, channel_id, thread_ts, working_directory, created_at, updated_at FROM threads
WHERE channel_id = ? AND thread_ts = ?
LIMIT 1
`

type GetThreadParams struct {
	ChannelID string `json:"channel_id"`
	ThreadTs  string `json:"thread_ts"`
}

func (q *Queries) GetThread(ctx context.Context, arg GetThreadParams) (Thread, error) {
	row := q.queryRow(ctx, q.getThreadStmt, getThread, arg.ChannelID, arg.ThreadTs)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.WorkingDirectory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getThreadByID = `-- name: GetThreadByID :one
SELECT id, channel_id, thread_ts, working_directory, created_at, updated_at FROM threads
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetThreadByID(ctx context.Context, id int64) (Thread, error) {
	row := q.queryRow(ctx, q.getThreadByIDStmt, getThreadByID, id)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.WorkingDirectory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getThreadByThreadTs = `-- name: GetThreadByThreadTs :one
SELECT id, channel_id, thread_ts, working_directory, created_at, updated_at FROM threads
WHERE thread_ts = ?
LIMIT 1
`

func (q *Queries) GetThreadByThreadTs(ctx context.Context, threadTs string) (Thread, error) {
	row := q.queryRow(ctx, q.getThreadByThreadTsStmt, getThreadByThreadTs, threadTs)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.ChannelID,
		&i.ThreadTs,
		&i.WorkingDirectory,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listThreads = `-- name: ListThreads :many
SELECT id, channel_id, thread_ts, working_directory, created_at, updated_at FROM threads
ORDER BY updated_at DESC
`

func (q *Queries) ListThreads(ctx context.Context) ([]Thread, error) {
	rows, err := q.query(ctx, q.listThreadsStmt, listThreads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.ThreadTs,
			&i.WorkingDirectory,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreadsPaginated = `-- name: ListThreadsPaginated :many
SELECT 
    t.id, t.channel_id, t.thread_ts, t.working_directory, t.created_at, t.updated_at,
    s.initial_prompt AS first_session_prompt
FROM threads t
LEFT JOIN (
    SELECT 
        thread_id,
        initial_prompt,
        ROW_NUMBER() OVER (PARTITION BY thread_id ORDER BY started_at ASC) as rn
    FROM sessions
) s ON t.id = s.thread_id AND s.rn = 1
ORDER BY t.updated_at DESC
LIMIT ? OFFSET ?
`

type ListThreadsPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListThreadsPaginatedRow struct {
	ID                 int64          `json:"id"`
	ChannelID          string         `json:"channel_id"`
	ThreadTs           string         `json:"thread_ts"`
	WorkingDirectory   string         `json:"working_directory"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	UpdatedAt          sql.NullTime   `json:"updated_at"`
	FirstSessionPrompt sql.NullString `json:"first_session_prompt"`
}

func (q *Queries) ListThreadsPaginated(ctx context.Context, arg ListThreadsPaginatedParams) ([]ListThreadsPaginatedRow, error) {
	rows, err := q.query(ctx, q.listThreadsPaginatedStmt, listThreadsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListThreadsPaginatedRow
	for rows.Next() {
		var i ListThreadsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ChannelID,
			&i.ThreadTs,
			&i.WorkingDirectory,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FirstSessionPrompt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateThreadTimestamp = `-- name: UpdateThreadTimestamp :exec
UPDATE threads
SET updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateThreadTimestamp(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.updateThreadTimestampStmt, updateThreadTimestamp, id)
	return err
}
